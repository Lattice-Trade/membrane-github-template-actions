name: Deploy to prod

on:
  workflow_call:
    inputs:
      AWS_REGION:
        required: true
        type: string
      ECR_REPOSITORY:
        required: true
        type: string
      TASK_DEFINITION:
        required: true
        type: string
      ECS_SERVICE:
        required: true
        type: string
      ECS_CLUSTER:
        required: true
        type: string
      CONTAINER_NAME:
        required: true
        type: string
    secrets:
      NPM_TOKEN:
        required: true
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      NEW_RELIC_ACCOUNT_ID:
        required: true
      NEW_RELIC_API_KEY:
        required: true
      NEW_RELIC_APPLICATION_ID:
        required: true

jobs:
  ci:
    if: ${{ github.event.pull_request.merged == true }} 
    name: ci
    runs-on: ubuntu-latest
    timeout-minutes: 60    
    steps:
    - name: Checkout
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ inputs.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Use cache dependencies
      uses: actions/cache@v3
      with:
        path: ~/.npm
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node-

    - name: Install dependencies
      if: steps.cache.outputs.cache-hit != 'true'
      uses: actions/setup-node@v1
      with:
          node-version: 16
          registry-url: https://registry.npmjs.org/

    - name: Code build
      run: npm ci --ignore-scripts

    # - name: Run unit tests
    #   run: npm test

    - name: Run lint
      run: npm run lint

    - name: Build, and tag Docker image
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        docker build -f Dockerfile.prod -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG . --build-arg NPM_TOKEN=${NPM_TOKEN}

  cd:
    needs: ci
    if: ${{ github.event.pull_request.merged == true }} 
    name: cd to prod
    runs-on: ubuntu-latest
    timeout-minutes: 60
    environment: production
    steps:

    - uses: voxmedia/github-action-slack-notify-build@v1
      with:
        channel: dev-releases-prod
        status: STARTED
        color: good
      env:
        SLACK_BOT_TOKEN: ${{ secrets.SLACK_ALARMS_TOKEN }}

    - name: Checkout
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ inputs.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1
  
    - name: Install dependencies
      if: steps.cache.outputs.cache-hit != 'true'
      uses: actions/setup-node@v1
      with:
          node-version: 16
          registry-url: https://registry.npmjs.org/
          
    - name: Code build
      run: npm ci --ignore-scripts

    - name: Build, and tag Docker image
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        docker build -f Dockerfile.prod -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG . --build-arg NPM_TOKEN=${NPM_TOKEN}

    - name: Build, tag, and push image to Amazon ECR
      id: build-push-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        docker build -f Dockerfile.prod -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -t $ECR_REGISTRY/$ECR_REPOSITORY:latest . --build-arg NPM_TOKEN=${NPM_TOKEN}
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        echo "::set-output name=image::$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
          image-ref: '${{ steps.login-ecr.outputs.registry }}/${{ inputs.ECR_REPOSITORY }}:${{ github.sha }}'
          format: 'table'
          exit-code: '0'
          ignore-unfixed: true
          vuln-type: 'os,library'
          severity: 'CRITICAL,HIGH'
      env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ inputs.AWS_REGION }}
   
    - name: Download task definition
      run: |
        aws ecs describe-task-definition --task-definition ${TASK_DEFINITION} --query taskDefinition > task-definition.json
        
    - name: Fill in the new image ID in the Amazon ECS task definition
      id: task-def
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: task-definition.json
        container-name: ${{ inputs.CONTAINER_NAME }}
        image: ${{ steps.build-push-image.outputs.image }}

    - name: Deploy Amazon ECS task definition
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: ${{ steps.task-def.outputs.task-definition }}
        service: ${{ inputs.ECS_SERVICE }}
        cluster: ${{ inputs.ECS_CLUSTER }}
        wait-for-service-stability: false

    - name: Create New Relic deployment marker
      uses: newrelic/deployment-marker-action@v1
      with:
        accountId: ${{ secrets.NEW_RELIC_ACCOUNT_ID }}
        apiKey: ${{ secrets.NEW_RELIC_API_KEY }}
        applicationId: ${{ secrets.NEW_RELIC_APPLICATION_ID }}
        revision: "${{ github.ref }}-${{ github.sha }}"

    - name: Notify slack success
      if: success()
      env:
        SLACK_BOT_TOKEN: ${{ secrets.SLACK_ALARMS_TOKEN }}
      uses: voxmedia/github-action-slack-notify-build@v1
      with:
        channel: dev-releases-prod
        status: SUCCESS
        color: good

    - name: Notify slack fail
      if: failure()
      env:
        SLACK_BOT_TOKEN: ${{ secrets.SLACK_ALARMS_TOKEN }}
      uses: voxmedia/github-action-slack-notify-build@v1
      with:
        channel: dev-releases-prod
        status: FAILED
        color: danger

  publish-release:
    needs: cd
    name: publish-new-version-release
    runs-on: ubuntu-latest
    steps:
      - uses: jungwinter/split@v2
        id: split
        with:
          msg: '${{ github.event.pull_request.title }}'

      - name: Extract version from branch name
        run: |
          BRANCH_NAME="${{ github.event.pull_request.head.ref }}"

      - name: Create Release
        uses: thomaseizinger/create-release@1.0.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          target_commitish: ${{ github.event.pull_request.merge_commit_sha }}
          tag_name: ${{ steps.split.outputs._2 }}
          name: ${{ steps.split.outputs._2 }}
          draft: false
          prerelease: false

      - name: Merge main into staging branch
        uses: thomaseizinger/create-pull-request@1.0.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          head: main
          base: staging
          title: Merge main into staging branch
          body: |
            This PR merges the main branch back into staging.
            This happens to ensure that the updates that happend on the release branch, i.e. CHANGELOG and manifest updates are also present on the staging branch.

      - name: Checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Publish Sentry release
        uses: getsentry/action-release@v1
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT }}
          # SENTRY_URL: https://sentry.io/
        with:
          environment: production
          version: ${{ steps.split.outputs._2 }}
          
name: Deploy in AWS Elastic Container Services

on:
  workflow_call:
    inputs:
      AWS_REGION:
        required: true
        type: string
      ECR_REPOSITORY:
        required: true
        type: string
      GH_BRANCH_NAME:
        required: true
        type: string
      GH_ENV:
        required: true
        type: string
      GH_PR_MERGED:
        required: true
        type: boolean
      GH_SHA:
        required: true
        type: string
      GH_REF:
        required: true
        type: string
      SLACK_CHANNEL:
        required: true
        type: string
      NEW_RELIC_APPLICATION_ID:
        required: false
        type: string
      NODE_VERSION:
        required: true
        type: string
      GH_VERSION:
        required: false
        type: string
    outputs:
      IMAGE_NAME:
        description: "The image name"
        value: ${{ jobs.cd.outputs.IMAGE_NAME }}
      IMAGE_TAG_DEV:
        description: "The image tag develop"
        value: ${{ jobs.cd.outputs.IMAGE_TAG_DEV }}
      IMAGE_TAG_STG:
        description: "The image tag staging"
        value: ${{ jobs.cd.outputs.IMAGE_TAG_STG }}

jobs:
  promote-staging-to-prod:
    if: ${{ inputs.GH_PR_MERGED && inputs.GH_BRANCH_NAME == 'main' }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
    - name: Checkout
      uses: actions/checkout@v3
      with:
        ref: main
    - name: Fetch current app version
      id: version
      run: echo "OUTPUT=$(jq .version ${{ inputs.METADATA_PACKAGE }})" >> $GITHUB_ENV
    - name: Promote image from staging to production
      uses: Lattice-Trade/membrane-github-template-actions/.github/workflows/docker-promote-image.yml@feature/LM-9164-step-deduplication
      with:
        AWS_REGION: ${{ inputs.AWS_REGION }}
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_ACCESS_KEY_ID_PROD: ${{ secrets.AWS_ACCESS_KEY_ID_PROD }}
        AWS_SECRET_ACCESS_KEY_PROD: ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}
        GH_VERSION: ${{ steps.version.OUTPUT }}
        ECR_REPOSITORY: ${{ inputs.ECR_REPOSITORY }}

  # cd:
  #   if: ${{ inputs.GH_PR_MERGED }}
  #   name: deploy to ${{ inputs.GH_ENV }}
  #   runs-on: ubuntu-latest
  #   timeout-minutes: 60
  #   environment: ${{ inputs.GH_ENV }}
  #   env:
  #     NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
  #   outputs:
  #     IMAGE_NAME: ${{ steps.image-name.outputs.IMAGE_NAME }}
  #     IMAGE_TAG_DEV: ${{ steps.image-build-tag-develop.outputs.IMAGE_TAG_DEV }}
  #     IMAGE_TAG_STG: ${{ steps.image-build-tag-staging.outputs.IMAGE_TAG_STG }}
  #   steps:
  #     - name: Sets env vars for nonprod
  #       if: ${{ inputs.GH_BRANCH_NAME != 'main' }}
  #       run: |
  #         echo "AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID_NONPROD }}" >> $GITHUB_ENV
  #         echo "AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY_NONPROD }}" >> $GITHUB_ENV
  #         echo "ECR_REPOSITORY=${{ inputs.ECR_NAME }}" >> $GITHUB_ENV

  #     # This step is run when the tag is staging-XXX
  #     - name: Sets env vars for prod
  #       if: ${{ inputs.GH_BRANCH_NAME == 'main' }}
  #       run: |
  #         echo "AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID_NONPROD }}" >> $GITHUB_ENV
  #         echo "AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY_NONPROD }}" >> $GITHUB_ENV
  #         echo "ECR_REPOSITORY=${{ inputs.ECR_NAME }}" >> $GITHUB_ENV

  #     - name: Generate image name
  #       id: image-name
  #       run: |
  #         #Set image name and tag as output
  #         ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
  #         echo "IMAGE_NAME=$ACCOUNT_ID.dkr.ecr.us-east-2.amazonaws.com/$ECR_REPOSITORY" >> $GITHUB_OUTPUT

  #     - name: Generate image tag with github sha commit
  #       id: image-build-tag-develop
  #       if: ${{ inputs.GH_VERSION == '' && inputs.GH_ENV == 'develop' }}
  #       run: |
  #         IMAGE_TAG=$(git rev-parse --short HEAD)
  #         docker build --build-arg NPM_TOKEN=${{ secrets.NPM_TOKEN }} -t ${{ steps.image-name.outputs.IMAGE_NAME }}:$IMAGE_TAG .
  #         docker push ${{ steps.image-name.outputs.IMAGE_NAME }}:$IMAGE_TAG
  #         echo "IMAGE_TAG_DEV=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

  #     - name: Generate image tag with version pre-release
  #       id: image-build-tag-staging
  #       if: ${{ inputs.GH_VERSION != '' && inputs.GH_ENV == 'staging' }}
  #       run: |
  #         IMAGE_TAG=${{ inputs.GH_VERSION }}
  #         docker build --build-arg NPM_TOKEN=${{ secrets.NPM_TOKEN }} -t ${{ steps.image-name.outputs.IMAGE_NAME }}:$IMAGE_TAG .
  #         docker push ${{ steps.image-name.outputs.IMAGE_NAME }}:$IMAGE_TAG
  #         echo "IMAGE_TAG_STG=${{ inputs.GH_VERSION }}" >> $GITHUB_OUTPUT

      # Deprecated in favor of Argo Notifications
      # - name: Notify slack success
      #   if: success()
      #   env:
      #     SLACK_BOT_TOKEN: ${{ secrets.SLACK_ALARMS_TOKEN }}
      #   uses: Lattice-Trade/github-action-slack-notify-build@main
      #   with:
      #     channel: ${{ inputs.SLACK_CHANNEL }}
      #     status: SUCCESS
      #     color: good

      # - name: Notify slack fail
      #   if: failure()
      #   env:
      #     SLACK_BOT_TOKEN: ${{ secrets.SLACK_ALARMS_TOKEN }}
      #   uses: Lattice-Trade/github-action-slack-notify-build@main
      #   with:
      #     channel: ${{ inputs.SLACK_CHANNEL }}
      #     status: FAILED
      #     color: danger
